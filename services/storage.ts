import { Order, Employee, Announcement, MenuCategory, MenuConfig, AdminAccount, OrderStatus } from '../types';
import { db as firestoreDb, isFirebaseConfigured } from './firebase';
import { collection, getDocs, updateDoc, deleteDoc, doc, query, orderBy, where, setDoc, getDoc } from 'firebase/firestore';

/**
 * DATABASE SERVICE (Firebase Edition)
 * Supports dual mode: LocalStorage vs Firestore
 */

const STORAGE_KEYS = {
  ORDERS: 'cofoodie_orders',
  MENU_CATEGORIES: 'cofoodie_menus_v3',
  EMPLOYEES: 'cofoodie_employees_v2',
  ANNOUNCEMENTS: 'cofoodie_announcements',
  ADMIN_SETTINGS: 'cofoodie_admin_settings',
  ADMIN_ACCOUNTS: 'cofoodie_admin_accounts',
  SESSION: 'cofoodie_session',
  SESSION_USER_ID: 'cofoodie_session_user_id',
  FRONTEND_PASSWORD: 'cofoodie_frontend_password'
};

const INITIAL_MENUS: MenuCategory[] = [];
const INITIAL_EMPLOYEES: Employee[] = [];
const INITIAL_ANNOUNCEMENTS: Announcement[] = [];
const INITIAL_ADMINS: AdminAccount[] = [
  { id: 'default_admin', name: '預設管理員', username: 'admin', password: 'password', isSuperAdmin: true }
];
const DEFAULT_FRONTEND_PWD = '123'; // Default fallback

class StorageService {
  private get useCloud() {
    return isFirebaseConfigured;
  }

  // --- Orders ---
  async getOrders(): Promise<Order[]> {
    if (this.useCloud) {
      try {
        const q = query(collection(firestoreDb, 'orders'), orderBy('timestamp', 'desc'));
        const querySnapshot = await getDocs(q);
        return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Order));
      } catch (e) {
        console.error('Fetch Orders Error:', e);
        return [];
      }
    }
    const data = localStorage.getItem(STORAGE_KEYS.ORDERS);
    return data ? JSON.parse(data) : [];
  }

  async saveOrder(order: Order): Promise<void> {
    if (this.useCloud) {
      // We use setDoc with explicit ID if provided, or addDoc if not? 
      // Order usually has ID generated by frontend 'ORD_xxx'. 
      // Firestore works best if we let it gen ID, but here we want to keep frontend ID as document ID for consistency.
      const { id, ...orderData } = order;
      await setDoc(doc(firestoreDb, 'orders', id), orderData);
      return;
    }
    const orders = await this.getOrders();
    orders.push(order);
    localStorage.setItem(STORAGE_KEYS.ORDERS, JSON.stringify(orders));
  }

  async updateOrderStatus(orderId: string, status: OrderStatus): Promise<void> {
    if (this.useCloud) {
      const orderRef = doc(firestoreDb, 'orders', orderId);
      await updateDoc(orderRef, { status });
      return;
    }
    const orders = await this.getOrders();
    const index = orders.findIndex(o => o.id === orderId);
    if (index !== -1) {
      orders[index].status = status;
      localStorage.setItem(STORAGE_KEYS.ORDERS, JSON.stringify(orders));
    }
  }

  async toggleOrderPayment(orderId: string): Promise<void> {
    if (this.useCloud) {
      // For toggle, strictly we should read then write or use transaction.
      // For simplicity: read -> update
      const orderRef = doc(firestoreDb, 'orders', orderId);
      // We can't easily toggle without reading first in client SDK without transaction
      // But since we are inside an async method, we can just do get -> update
      // Or actually, let's assume UI handles the state, but 'toggle' implies logic here.
      // Let's just fetch it first.
      // Actually, optimization: let frontend pass the new state? 
      // The interface says 'toggleOrderPayment', implies void.
      // Let's implement robustly.
      // Wait, there's no simple "toggle" update operator.
      // For now, let's just re-fetch all orders at UI level usually?
      // Let's try to get the specific doc.
      // Wait, I'll update imports.
      const orderSnap = await getDoc(orderRef);
      if (orderSnap.exists()) {
        const currentIsPaid = orderSnap.data().isPaid;
        await updateDoc(orderRef, { isPaid: !currentIsPaid });
      } else {
        console.error(`Order with ID ${orderId} not found for payment toggle.`);
      }
      return;
    }
    const orders = await this.getOrders();
    const index = orders.findIndex(o => o.id === orderId);
    if (index !== -1) {
      orders[index].isPaid = !orders[index].isPaid;
      localStorage.setItem(STORAGE_KEYS.ORDERS, JSON.stringify(orders));
    }
  }

  async deleteOrdersByContext(dateStr: string, categoryLabel: string): Promise<void> {
    if (this.useCloud) {
      try {
        const q = query(
          collection(firestoreDb, 'orders'),
          where('dateStr', '==', dateStr),
          where('categoryLabel', '==', categoryLabel)
        );
        const querySnapshot = await getDocs(q);
        const deletePromises = querySnapshot.docs.map(d => deleteDoc(doc(firestoreDb, 'orders', d.id)));
        await Promise.all(deletePromises);
      } catch (e) {
        console.error('Delete Orders Error:', e);
      }
      return;
    }
    let orders = await this.getOrders();
    orders = orders.filter(o => !(o.dateStr === dateStr && o.categoryLabel === categoryLabel));
    localStorage.setItem(STORAGE_KEYS.ORDERS, JSON.stringify(orders));
  }

  // --- Menu Categories ---
  async getMenuCategories(): Promise<MenuCategory[]> {
    if (this.useCloud) {
      const q = query(collection(firestoreDb, 'menus'));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as MenuCategory));
    }
    const data = localStorage.getItem(STORAGE_KEYS.MENU_CATEGORIES);
    return data ? JSON.parse(data) : INITIAL_MENUS;
  }

  async saveMenuCategories(menus: MenuCategory[]): Promise<void> {
    // Not used in Cloud mode
    if (this.useCloud) return;
    localStorage.setItem(STORAGE_KEYS.MENU_CATEGORIES, JSON.stringify(menus));
  }

  async addMenuCategory(label: string, config: MenuConfig): Promise<void> {
    if (this.useCloud) {
      const newId = 'MENU_' + Date.now();
      await setDoc(doc(firestoreDb, 'menus', newId), { label, config });
      return;
    }
    const menus = await this.getMenuCategories();
    const newId = 'MENU_' + Date.now();
    menus.push({ id: newId, label, config });
    await this.saveMenuCategories(menus);
  }

  async updateMenuCategory(id: string, label: string, config: MenuConfig): Promise<void> {
    if (this.useCloud) {
      await updateDoc(doc(firestoreDb, 'menus', id), { label, config });
      return;
    }
    const menus = await this.getMenuCategories();
    const idx = menus.findIndex(m => m.id === id);
    if (idx !== -1) {
      menus[idx].label = label;
      menus[idx].config = config;
      await this.saveMenuCategories(menus);
    }
  }

  async deleteMenuCategory(id: string): Promise<void> {
    if (this.useCloud) {
      await deleteDoc(doc(firestoreDb, 'menus', id));
      return;
    }
    let menus = await this.getMenuCategories();
    menus = menus.filter(m => m.id !== id);
    await this.saveMenuCategories(menus);
  }

  // --- Employees ---
  async getEmployees(): Promise<Employee[]> {
    if (this.useCloud) {
      const q = query(collection(firestoreDb, 'employees'), orderBy('name')); // Simple sort
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Employee));
    }
    const data = localStorage.getItem(STORAGE_KEYS.EMPLOYEES);
    return data ? JSON.parse(data) : INITIAL_EMPLOYEES;
  }

  async saveEmployees(list: Employee[]): Promise<void> {
    if (this.useCloud) return;
    localStorage.setItem(STORAGE_KEYS.EMPLOYEES, JSON.stringify(list));
  }

  async addEmployee(emp: Employee): Promise<void> {
    if (this.useCloud) {
      const { id, ...data } = emp;
      await setDoc(doc(firestoreDb, 'employees', id), data);
      return;
    }
    const list = await this.getEmployees();
    list.push(emp);
    await this.saveEmployees(list);
  }

  async updateEmployee(updatedEmp: Employee): Promise<void> {
    if (this.useCloud) {
      await updateDoc(doc(firestoreDb, 'employees', updatedEmp.id), { name: updatedEmp.name });
      return;
    }
    const list = await this.getEmployees();
    const newList = list.map(e => e.id === updatedEmp.id ? updatedEmp : e);
    await this.saveEmployees(newList);
  }

  async deleteEmployee(id: string): Promise<void> {
    if (this.useCloud) {
      await deleteDoc(doc(firestoreDb, 'employees', id));
      return;
    }
    const list = await this.getEmployees();
    const newList = list.filter(e => e.id !== id);
    await this.saveEmployees(newList);
  }

  // --- Announcements ---
  async getAnnouncements(): Promise<Announcement[]> {
    if (this.useCloud) {
      const q = query(collection(firestoreDb, 'announcements'));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Announcement));
    }
    const data = localStorage.getItem(STORAGE_KEYS.ANNOUNCEMENTS);
    return data ? JSON.parse(data) : INITIAL_ANNOUNCEMENTS;
  }

  async saveAnnouncements(list: Announcement[]): Promise<void> {
    if (this.useCloud) {
      // Batch update is tricky if full replace.
      // For now, let's just handle individual Adds via specific methods usually.
      // But logic here was 'save list'. 
      // Let's loop upsert (setDoc with merge).
      for (const a of list) {
        await setDoc(doc(firestoreDb, 'announcements', a.id), { content: a.content, isActive: a.isActive }, { merge: true });
      }
      return;
    }
    localStorage.setItem(STORAGE_KEYS.ANNOUNCEMENTS, JSON.stringify(list));
  }

  // --- Admin Settings & Accounts ---
  async getAdminSettings() {
    if (this.useCloud) {
      return { isGoogleBound: true, googleAccountName: 'Firebase Mode', googleAccountType: 'WORKSPACE' };
    }
    const data = localStorage.getItem(STORAGE_KEYS.ADMIN_SETTINGS);
    return data ? JSON.parse(data) : {
      isGoogleBound: false,
      googleAccountName: '',
      googleAccountType: 'PERSONAL'
    };
  }

  async setGoogleBound(isBound: boolean, accountName: string = '', accountType: 'PERSONAL' | 'WORKSPACE' = 'PERSONAL') {
    const settings = {
      isGoogleBound: isBound,
      googleAccountName: accountName,
      googleAccountType: accountType
    };
    localStorage.setItem(STORAGE_KEYS.ADMIN_SETTINGS, JSON.stringify(settings));
  }

  async checkDatabaseConnection(): Promise<boolean> {
    if (this.useCloud) {
      try {
        await getDocs(collection(firestoreDb, 'admins'));
        return true;
      } catch {
        return false;
      }
    }
    // Simulate local
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, 1000);
    });
  }

  async getAdminAccounts(): Promise<AdminAccount[]> {
    if (this.useCloud) {
      const q = query(collection(firestoreDb, 'admins'));
      const querySnapshot = await getDocs(q);
      const results = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as AdminAccount));

      // If empty, init default?
      if (results.length === 0) {
        // Auto init
        for (const admin of INITIAL_ADMINS) {
          await setDoc(doc(firestoreDb, 'admins', admin.id), { ...admin });
        }
        return INITIAL_ADMINS;
      }
      return results;
    }
    const data = localStorage.getItem(STORAGE_KEYS.ADMIN_ACCOUNTS);
    if (!data) {
      localStorage.setItem(STORAGE_KEYS.ADMIN_ACCOUNTS, JSON.stringify(INITIAL_ADMINS));
      return INITIAL_ADMINS;
    }
    return JSON.parse(data);
  }

  async saveAdminAccounts(admins: AdminAccount[]): Promise<void> {
    if (this.useCloud) return;
    localStorage.setItem(STORAGE_KEYS.ADMIN_ACCOUNTS, JSON.stringify(admins));
  }

  async verifyAdmin(username: string, password: string): Promise<AdminAccount | null> {
    if (this.useCloud) {
      if (!firestoreDb) return null;

      // Check if any admins exist at all
      const adminsRef = collection(firestoreDb, 'admins');
      const allAdminsSnapshot = await getDocs(adminsRef);

      if (allAdminsSnapshot.empty) {
        console.log('No admins found in DB, seeding default admins...');
        // Seed default admins
        for (const admin of INITIAL_ADMINS) {
          await setDoc(doc(firestoreDb, 'admins', admin.id), { ...admin });
        }
      }

      // Now check credential
      const q = query(adminsRef, where('username', '==', username), where('password', '==', password));
      const snapshot = await getDocs(q);

      if (snapshot.empty) return null;

      const docSnap = snapshot.docs[0];
      return { id: docSnap.id, ...docSnap.data() } as AdminAccount;
    }
    const admins = await this.getAdminAccounts();
    const admin = admins.find(a => a.username === username && a.password === password);
    return admin || null;
  }

  async getAdminById(id: string): Promise<AdminAccount | undefined> {
    const admins = await this.getAdminAccounts();
    return admins.find(a => a.id === id);
  }

  async addAdminAccount(account: AdminAccount): Promise<void> {
    if (this.useCloud) {
      // Check exist
      const q = query(collection(firestoreDb, 'admins'), where('username', '==', account.username));
      const snapshot = await getDocs(q);
      if (!snapshot.empty) throw new Error('帳號已存在');

      const { id, ...data } = account;
      await setDoc(doc(firestoreDb, 'admins', id), data);
      return;
    }
    const admins = await this.getAdminAccounts();
    if (admins.some(a => a.username === account.username)) {
      throw new Error('帳號已存在');
    }
    admins.push(account);
    await this.saveAdminAccounts(admins);
  }

  async updateAdminAccount(updated: AdminAccount): Promise<void> {
    if (this.useCloud) {
      const { id, ...data } = updated;
      await updateDoc(doc(firestoreDb, 'admins', id), data);
      return;
    }
    const admins = await this.getAdminAccounts();
    const idx = admins.findIndex(a => a.id === updated.id);
    if (idx !== -1) {
      admins[idx] = updated;
      await this.saveAdminAccounts(admins);
    }
  }

  async deleteAdminAccount(id: string): Promise<void> {
    if (this.useCloud) {
      await deleteDoc(doc(firestoreDb, 'admins', id));
      return;
    }
    let admins = await this.getAdminAccounts();
    admins = admins.filter(a => a.id !== id);
    await this.saveAdminAccounts(admins);
  }

  // --- Frontend Password ---
  async getFrontendPassword(): Promise<string> {
    // Keep local for simplicity unless requested
    const pwd = localStorage.getItem(STORAGE_KEYS.FRONTEND_PASSWORD);
    return pwd || DEFAULT_FRONTEND_PWD;
  }

  async setFrontendPassword(password: string): Promise<void> {
    localStorage.setItem(STORAGE_KEYS.FRONTEND_PASSWORD, password);
  }

  // --- Session (Keep Local) ---
  setSession(role: 'USER' | 'ADMIN', userId?: string) {
    localStorage.setItem(STORAGE_KEYS.SESSION, role);
    if (userId) {
      localStorage.setItem(STORAGE_KEYS.SESSION_USER_ID, userId);
    }
  }

  getSession(): { role: 'USER' | 'ADMIN' | null, userId: string | null } {
    const role = localStorage.getItem(STORAGE_KEYS.SESSION) as 'USER' | 'ADMIN' | null;
    const userId = localStorage.getItem(STORAGE_KEYS.SESSION_USER_ID);
    return { role, userId };
  }

  clearSession() {
    localStorage.removeItem(STORAGE_KEYS.SESSION);
    localStorage.removeItem(STORAGE_KEYS.SESSION_USER_ID);
  }
}

export const dbService = new StorageService();
export const db = dbService; // Alias for backward compatibility if named 'db' elsewhere